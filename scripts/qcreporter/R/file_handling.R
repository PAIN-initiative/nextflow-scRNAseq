#' Load config file
#'
#' Loads a csv config file of analysis parameters
#'
#' Parameter file should have columns "parameter" containing parameter names,
#' "value" containing parameter values, and "type" containing variable classes.
#'
#' @param in_config Character value. Full file path to the config file.
#' @param vector_delim Character value. Delimiter to use to convert string to vector
#'
#' @return A list of parameters. Names from "parameter" and values from "value"
#' with classes defined per "type"
#' @export
#' @examples
#' my_config <- system.file("extdata/default_rna_config_v1.csv", package = "batchreporter")
#' cnfg <- load_config(my_config)
load_config <- function(in_config, vector_delim = ";"){
  # Read file in
  df <- read.csv(in_config, stringsAsFactors = FALSE)

  # check file expectations
  assertthat::assert_that(all(c("parameter", "value", "type") %in% names(df)))

  # Create variables for each "parameter" with value "value"
  lconfig <- as.list(df$value)
  names(lconfig) <- df$parameter

  # Convert delimited strings to vectors
  lconfig <- sapply(lconfig, strsplit, split = vector_delim)

  # Assign classes based on "type" column
  lconfig <- mapply(function(x,y){
    if(y == "factor") factor(x, levels = unique(x))
    else class(x) <- y; x
  },lconfig, df$type)

  return(lconfig)
}

#' Validate configuration
#'
#' Validate that configuration contains expected parameters and those parameters
#' are non-missing
#'
#' @param cnfg Configuration paramter list generated by \code{batchreporter::load_config()}
#' @param expected_parameters Character object. Vector of expected parameter names
#' in the cnfg list
#'
#' @return NULL. If missing parameters, error is thrown with descriptive message
#' @export
validate_config <- function(cnfg, expected_parameters){
  if(!all(expected_parameters %in% names(cnfg))){
    p_missing <- setdiff(expected_parameters, names(cnfg))
    stop(sprintf("Missing parameters in configuration file: %s",
                 paste(p_missing, collapse = ", ")))
  }

  cnfg_no_NA <- cnfg[!is.na(cnfg)]
  if(!all(expected_parameters %in% names(cnfg_no_NA))){
    p_NA <- setdiff(expected_parameters, names(cnfg_no_NA))
    stop(sprintf("Missing values for expected parameters in configuration file: %s",
                 paste(p_NA, collapse = ", ")))
  }
}

#' Read H5 Well Metadata
#'
#' Read in 10x well metadata from an H5 file. Metadata is injected to the
#' 10x Genomics cellranger h5 output by AIFI pipeline code.
#'
#' @param h5_file the path to an .h5 file with metadata injection by AIFI pipeline.
#' @param target A specific matrix object in the .h5 file. Default is "well". Can also work with any matrix-like object
#' nested further if target is equal to the full path (ie matrix/features)--matrix will be read in as-is.
#' For reading cell level metadata use \code{H5MANIPULATOR::read_h5_cell_metadata()} and for reading
#' sparse matrixes use \code{H5MANIPULATOR::read_h5_dgCMatrix()}
#' @return A data.frame containing all feature metadata found in /well
#' @export
read_h5_well_meta <- function (h5_file, target = "well") {
  assertthat::assert_that(is.character(h5_file))
  assertthat::assert_that(length(h5_file) == 1)
  target <- ifelse(grepl("^/", target), target, paste0("/",
                                                       target))
  h5_contents <- H5MANIPULATOR::h5ls(h5_file)
  target_contents <- h5_contents[grepl(paste0("^", target,"$"),
                                       h5_contents$group), ]
  h5_meta_targets <- target_contents$full_name

  if (length(h5_meta_targets) > 0) {
    meta_list <- lapply(h5_meta_targets, function(h5_meta_target) {
      rhdf5::h5read(h5_file, h5_meta_target)
    })
    rhdf5::h5closeAll()
    names(meta_list) <- sub(".+/", "", h5_meta_targets)
    meta_list <- H5MANIPULATOR::strip_1d_array_recursive(meta_list)
    meta_list <- H5MANIPULATOR::convert_char_na_recursive(meta_list)
    df <- as.data.frame(meta_list, stringsAsFactors = FALSE)
    if("well_id" %in% names(df)){
      df <- df[, c("well_id", setdiff(names(df),"well_id"))]
    }
    df
  }
  else {
    stop("No well metadata found in h5_file.")
  }
}

#' Read in HTO Processing Metrics JSON Files
#'
#' @param fp Full file path to a single json file to be read. JSON files are generated
#' by the AIFI pipeline
#' @param sample_column_name Name to use for the sample id's. Ie for pbmc runs use
#' "pbmc_sample_id" (default) since the pipeline uses this column name in the metadata. Column
#' name may be different in future for other sample types.
#' @return A data frame of select hashing information for each well and HTO
#' @export
#' @examples
#' raw_json <- system.file("extdata/X002/hash/X002-P1C1W4_hto_processing_metrics.json",
#'                        package = "batchreporter")
#' df_json <- read_hto_well_json(raw_json)
#' head(df_json)
read_hto_well_json <- function(fp, sample_column_name = "pbmc_sample_id"){
  assertthat::assert_that(length(fp) == 1, msg = "Input fp is not length 1")

  json_list <- jsonlite::read_json(fp)

  well_id <- json_list$well_id
  sample_stats_list <- json_list$pbmc_sample_hto_stats
  sample_stats_df_list <- lapply(seq_along(sample_stats_list), function(i){
    df <- data.frame(names(sample_stats_list)[i])
    names(df)[1] <- sample_column_name
    stats_list <- lapply(sample_stats_list[[i]], function(x){
      ifelse(is.null(x),NA, x)
    })
    df <- cbind(df, as.data.frame(stats_list))
    df
  })

  sample_stats_df <- do.call(rbind, sample_stats_df_list)
  results <- data.frame(well_id = rep(well_id, nrow (sample_stats_df)),sample_stats_df)
}

